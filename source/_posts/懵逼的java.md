---
title: 懵逼的java
date: 2017-05-26 15:39:03
tags: 技术研究
toc: true
categories: 教程
---

<blockquote class="blockquote-center">周六要上班</blockquote>

*今天在论坛看到一个很有意思的问题，自认为对java略有心得，但是按照以往的思维，做错了！*
<!--more-->
### 题目是这样的

```java
	public static void main(String[] args) {
		//输出顺序和a，b的值
		staticFunction();
	}

	static Stscan st = new Stscan();

	static {
		System.out.println("1");
	}
	{

		System.out.println("2");
	}

	Stscan() {
		System.out.println("3");
		System.out.println("a=" + a + " b=" + b);
	}

	public static void staticFunction() {
		System.out.println("4");
	}

	int a = 110;

	static int b = 112;
```

输出的顺序和 a,b的值：

开始按照java的赋值顺序：
- 1.父类的静态变量赋值
- 2.自身的静态变量赋值
- 3.父类成员变量赋值
- 4.父类块赋值
- 5.父类构造器赋值
- 6.自身成员变量赋值
- 7.自身块赋值
- 8.自身构造器赋值

但是还是不对，这就比较尴尬了。


但是后来发现：
可以从类的生命周期和对象的初始化来分析：
1.类的生命周期是：加载->验证->准备->解析->初始化->使用->卸载，只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值，因此只针对这两个阶段进行分析；
2.类的准备阶段需要做是为类变量分配内存并设置默认值，因此类变量st为null、b为0；（需要注意的是如果类变量是final在加载阶段就已经完成了初始化，可以把b设置为final试试）；
3.类的初始化阶段需要做是执行类构造器（类构造器是编译器收集所有静态语句块和类变量的赋值语句按语句在源码中的顺序合并生成类构造器，对象的构造方法是init，类的构造方法是cinit，可以在堆栈信息中看到），因此先执行第一条静态变量的赋值语句即st = new StaticTest ()，此时会进行对象的初始化，对象的初始化是先初始化成员变量再执行构造方法，因此打印2->设置a为110->执行构造方法(打印3,此时a已经赋值为110，但是b只是设置了默认值0，并未完成赋值动作)，等对象的初始化完成后继续执行之前的类构造器的语句，接下来就不详细说了，按照语句在源码中的顺序执行即可；


我们来看一个简化的代码:

```java
public class Test {
    public static void main(String[] args) {
        func();
    }
     
    static Test st = new Test();
     
    static void func(){}
 
}
```

- 1、首先在执行此段代码时，首先由main方法的调用触发静态初始化。
- 2、在初始化Test 类的静态部分时，遇到st这个成员。
- 3、但凑巧这个变量引用的是本类的实例。
- 4、那么问题来了，此时静态初始化过程还没完成就要初始化实例部分了。是这样么？
- 5、从人的角度是的。但从java的角度，一旦开始初始化静态部分，无论是否完成，后续都不会再重新触发静态初始化流程了。
- 6、因此在实例化st变量时，实际上是把实例初始化嵌入到了静态初始化流程中，并且在楼主的问题中，嵌入到了静态初始化的起始位置。
	这就导致了实例初始化完全至于静态初始化之前。这也是导致a有值b没值的原因。
- 7、最后再考虑到文本顺序，结果就显而易见了。

**路漫漫**